{"id":"b992c6bc-511d-415f-8bc6-e580bc1372e5","zed":"context","version":"0.4.0","text":"\n\n\n\n```ts settlers/packages/server/src/game/map/map.board.ts:1-373\n// Excerpt from: \nimport * as road_connections from './utils/road_connections.json';\nimport * as board_coordinates from './utils/board_coordinates.json';\nimport * as board_constants from './utils/board_constants.json';\nimport { Logger } from '@nestjs/common';\nimport {\n  Delta,\n  GameAction,\n  Resource,\n  Road,\n  ServerEvents,\n  ServerPayloads,\n  SettlementType,\n  Spot,\n  Tile,\n} from '@settlers/shared';\nimport { Socket } from 'socket.io';\nimport { randomInt } from 'crypto';\nimport { bfs_roads, bfs_spots } from './utils/bfs';\nimport {\n  roadScreenPosition,\n  screenPosition,\n  spotBoardPosition,\n  tileBoardPosition,\n} from 'packages/shared/src/lib/common/BoardTypes';\n\nexport class MapBoard {\n  private NUM_SPOTS = 54;\n  private Y_SPOT = 0.2;\n  private Y_ROAD = 0.18;\n  private Y_TILE = 0;\n  private HEX_SIZE = 0.6;\n  public spots: Map<Spot['id'], Spot> = new Map<Spot['id'], Spot>();\n  public tiles: Map<Tile['id'], Tile> = new Map<Tile['id'], Tile>();\n  public roads: Map<Road['id'], Road> = new Map<Road['id'], Road>();\n  deltas: Delta[] = [];\n\n  // potrebbe essere overkill, basta l'id e non l'intera road\n  public roadsGraph: {\n    [from: Spot['id']]: {\n      [to: Spot['id']]: Road;\n    };\n  } = {};\n\n  constructor() {\n    for (let i = 1; i <= this.NUM_SPOTS; i++) {\n      this.roadsGraph[i] = {};\n    }\n  }\n\n  // initalise the graph\n  public initSpot(\n    spot_id: Spot['id'],\n    tilePositionBoard: tileBoardPosition,\n    spotPositionBoard: spotBoardPosition\n  ): void {\n    // get screen position of tile\n    const tileScreenPosition = this.tileBoardToScreen(tilePositionBoard);\n\n    // get spot position on screen\n    const spotTileCorner = spotPositionBoard.tileCorner;\n    const spotPositionScreen = this.spotBoardToScreen(\n      tileScreenPosition,\n      spotTileCorner\n    );\n\n    const spotData = {\n      id: spot_id,\n      owner: null,\n      settlementType: null,\n      position: {\n        screen: {\n          ...spotPositionScreen,\n        },\n        board: {\n          ...spotPositionBoard,\n        },\n      },\n    };\n    this.spots.set(spot_id, spotData);\n  }\n\n  public initRoad(\n    road_id: Road['id'],\n    spot1: Spot['id'],\n    spot2: Spot['id']\n  ): void {\n    const screenPosition: roadScreenPosition =\n      this.roadScreenPositionGivenSpots(spot1, spot2);\n\n    this.roadsGraph[spot1][spot2] = {\n      id: road_id,\n      owner: null,\n      position: {\n        board: {\n          from: spot1,\n          to: spot2,\n        },\n        screen: {\n          x: screenPosition.x,\n          y: screenPosition.y,\n          yangle: screenPosition.yangle,\n          z: screenPosition.z,\n        },\n      },\n    };\n    this.roadsGraph[spot2][spot1] = {\n      id: road_id,\n      owner: null,\n      position: {\n        board: {\n          from: spot2,\n          to: spot1,\n        },\n        screen: {\n          x: screenPosition.x,\n          y: screenPosition.y,\n          yangle: screenPosition.yangle,\n          z: screenPosition.z,\n        },\n      },\n    };\n    this.roads.set(road_id, {\n      id: road_id,\n      owner: null,\n      position: {\n        board: {\n          from: spot1,\n          to: spot2,\n        },\n        screen: {\n          x: screenPosition.x,\n          y: screenPosition.y,\n          yangle: screenPosition.yangle,\n          z: screenPosition.z,\n        },\n      },\n    });\n  }\n  public getDeltaUpdates(): ServerPayloads[ServerEvents.DeltaUpdate] {\n    const deltas = [...this.deltas];\n    this.deltas = [];\n    return deltas;\n  }\n\n  // helpers for coordinates\n  private spotBoardToScreen(\n    tileScreenPosition: screenPosition,\n    tileCorner: number\n  ): screenPosition {\n    const angle_deg = 60 * tileCorner + 30;\n    const angle_rad = (Math.PI / 180) * angle_deg;\n    const x = tileScreenPosition.x + this.HEX_SIZE * Math.cos(angle_rad);\n    const z = tileScreenPosition.z + this.HEX_SIZE * Math.sin(angle_rad);\n    return { x, y: this.Y_SPOT, z };\n  }\n\n  private tileBoardToScreen(boardPosition: tileBoardPosition): screenPosition {\n    const x =\n      this.HEX_SIZE *\n      (Math.sqrt(3) * boardPosition.q + (Math.sqrt(3) / 2) * boardPosition.r);\n    const z = this.HEX_SIZE * ((3 / 2) * boardPosition.r);\n    return { x, y: this.Y_TILE, z };\n  }\n\n  private roadScreenPositionGivenSpots(\n    spot1: Spot['id'],\n    spot2: Spot['id']\n  ): roadScreenPosition {\n    console.log('==');\n    // get spot positions on screen\n    const pos1: screenPosition = this.spots.get(spot1).position.screen;\n    const pos2: screenPosition = this.spots.get(spot2).position.screen;\n\n    // calculate mid point\n    const midX: number = (pos1.x + pos2.x) / 2;\n    const midZ: number = (pos1.z + pos2.z) / 2;\n\n    console.log(`spot ${spot1} pos ${pos1.x} ${pos1.y} ${pos1.z}`);\n    console.log(`spot ${spot2} pos ${pos2.x} ${pos2.y} ${pos2.z}`);\n\n    // calculate y rotation angle\n    let yangle: number;\n    if (pos1.x === pos2.x) {\n      // case: |\n      yangle = Math.PI / 2;\n      console.log('|');\n    } else if (pos1.x > pos2.x && pos1.z < pos2.z) {\n      // case /\n      yangle = Math.PI / 6;\n      console.log('/');\n    } else if (pos1.x < pos2.x && pos1.z < pos2.z) {\n      // case \\\n      yangle = (5 * Math.PI) / 6;\n      console.log('\\\\');\n    }\n\n    return {\n      x: midX,\n      y: this.Y_ROAD,\n      z: midZ,\n      yangle,\n    };\n  }\n\n  // main initialisation function for the board\n  public initBoard(): void {\n    // initialise the 'graph' part of the board aka spots/roads\n    const tilesCoordinates = board_coordinates['tiles'];\n    const spotsCoordinates = board_coordinates['spots'];\n    const roadsCoordinates = board_coordinates['roads'];\n\n    // tiles\n    const tileValues = board_constants['tileValues'].sort(\n      () => Math.random() - 0.5\n    );\n    const tileResources: Resource[] = board_constants['resourceValues'].sort(\n      () => Math.random() - 0.5\n    ) as Resource[];\n    let valueIndex = 0;\n\n    for (let i = 0; i < tileResources.length; i++) {\n      const tileValue =\n        tileResources[i] === 'ROBBERS' ? 7 : tileValues[valueIndex++];\n      const tilePositionBoard: tileBoardPosition =\n        tilesCoordinates[(i + 1).toString()];\n      const tilePositionScreen: screenPosition =\n        this.tileBoardToScreen(tilePositionBoard);\n\n      this.tiles.set(i + 1, {\n        resource: tileResources[i],\n        value: tileValue,\n        id: i + 1,\n        position: {\n          board: tilePositionBoard,\n          screen: tilePositionScreen,\n        },\n      });\n    }\n\n    // spots and roads - currently doing 2 for loops because\n    // to calculate road screen position i need spots positions\n    for (\n      let spotId = 1;\n      spotId <= Object.keys(spotsCoordinates).length;\n      spotId++\n    ) {\n      const spotPositionBoard: spotBoardPosition =\n        spotsCoordinates[spotId.toString()];\n      const tilePositionBoard: tileBoardPosition = this.tiles.get(\n        spotPositionBoard.tile\n      ).position.board;\n      this.initSpot(spotId, tilePositionBoard, spotPositionBoard);\n    }\n\n    for (\n      let spotId = 1;\n      spotId <= Object.keys(spotsCoordinates).length;\n      spotId++\n    ) {\n      const from = spotId.toString();\n\n      for (const to of Object.keys(road_connections[from])) {\n        const roadId = road_connections[from][to];\n        this.initRoad(parseInt(roadId), parseInt(from), parseInt(to));\n      }\n    }\n    Logger.log('Board initialised');\n  }\n\n  public getAdjacentSpots(spot_id: Spot['id']): Array<Spot['id']> {\n    const r = Object.keys(this.roadsGraph[spot_id]);\n    return [];\n  }\n\n  // building roads and settlements\n  public getAvailableSpots = (player: Socket['id']): Array<Spot> => {\n    const settlementsBuiltByPlayer = this.getSettlementsBuiltBy(player);\n    if (settlementsBuiltByPlayer.length < 2) {\n      return this.getSettlementsBuiltBy(null);\n    }\n    return bfs_spots(settlementsBuiltByPlayer, this.spots, this.roads, player);\n  };\n\n  public getAvailableRoads = (player: Socket['id']): Array<Road> => {\n    const settlementsBuiltByPlayer = this.getSettlementsBuiltBy(player);\n    return bfs_roads(\n      settlementsBuiltByPlayer,\n      this.spots,\n      this.roadsGraph,\n      player\n    );\n  };\n\n  // there is for sure a better way\n  public getSettlementsBuiltBy = (player: Socket['id'] | null): Array<Spot> => {\n    const playerTowns = [];\n    for (const [, spot] of this.spots.entries()) {\n      if (spot.owner === player) playerTowns.push(spot);\n    }\n    return playerTowns;\n  };\n\n  public buildSettlement(\n    spot_id: Spot['id'],\n    settlement_type: SettlementType,\n    player: Socket['id']\n  ): void {\n    const spot = this.spots.get(spot_id);\n    this.spots.set(spot_id, {\n      ...spot,\n      owner: player,\n      settlementType: settlement_type,\n    });\n\n    // adjacent spots are not buildable anymore\n    const adjs = this.getAdjacentSpots(spot_id);\n    for (const adj of adjs) {\n      console.log(adj);\n    }\n\n    this.deltas.push({\n      action: GameAction.ActionBuildSettlement,\n      player,\n      details: {\n        newSettlement: spot_id,\n        adjacent: [...adjs],\n      },\n      timestamp: Date.now(),\n    });\n  }\n\n  public buildRoad(\n    spot1: Spot['id'],\n    spot2: Spot['id'],\n    player: Socket['id']\n  ): void {\n    this.roadsGraph[spot1][spot2].owner = player;\n    this.roadsGraph[spot2][spot1].owner = player;\n\n    const roadId = this.roadsGraph[spot1][spot2].id;\n    const road = this.roads.get(roadId);\n    this.roads.set(roadId, {\n      ...road,\n      owner: player,\n    });\n\n    console.log(`built: ${this.roadsGraph[spot1][spot2]}`);\n    this.deltas.push({\n      action: GameAction.ActionBuildRoad,\n      player,\n      details: {\n        newRoad: this.roadsGraph[spot1][spot2],\n      },\n      timestamp: Date.now(),\n    });\n  }\n\n  public rollDice(player: Socket['id']): number[] {\n    const dice = [randomInt(1, 7), randomInt(1, 7)];\n\n    this.deltas.push({\n      action: GameAction.ActionDiceRoll,\n      player,\n      details: {\n        dice,\n      },\n      timestamp: Date.now(),\n    });\n\n    return dice;\n  }\n}\n\n```\nhere is setup my board.\nthis.roads should contain a raod, and specifically road.position.screen should contain `yangle`.\n\n\n```ts settlers/packages/server/src/game/instance/instance.ts:1-181\n// Excerpt from: \nimport {\n  ClientPayloads,\n  GameAction,\n  Road,\n  ServerEvents,\n  ServerPayloads,\n  Spot,\n  Tile,\n} from '@settlers/shared';\nimport { Lobby } from '../lobby/lobby';\nimport { AuthenticatedSocket } from '../types';\nimport { MapBoard } from '../map/map.board';\nimport { GameFSM } from './gamefsm';\nimport { Logger } from '@nestjs/common';\nimport { Socket } from 'socket.io';\nimport { TurnSystem } from './turnsys';\n\nexport class Instance {\n  // partita\n  public hasStarted = false;\n  public hasEnded = false;\n  public isPaused = false;\n  public currentRound = 0;\n  private board: MapBoard = new MapBoard();\n  private fsm: GameFSM = new GameFSM();\n  public players: Socket['id'][] = [];\n  public turns: TurnSystem;\n\n  constructor(public readonly lobby: Lobby) {}\n\n  /**\n   *  dispatching and sending to client(s)\n   *\n   */\n\n  // send available actions to the current player\n  public dispatchAvailableActions(): void {\n    const currentPlayerIndex = this.turns.getCurrentPlayerIndex();\n    const currentPlayer = this.turns.getCurrentPlayer();\n    const availableActions = this.fsm.getAvailableActions(currentPlayerIndex);\n\n    const actions: ServerPayloads[ServerEvents.AvailableActions] = {\n      availableActions,\n      buildableSpots:\n        availableActions.includes(GameAction.ActionSetupSettlement) ||\n        availableActions.includes(GameAction.ActionBuildSettlement)\n          ? this.board.getAvailableSpots(currentPlayer)\n          : null,\n      buildableRoads:\n        availableActions.includes(GameAction.ActionSetupRoad) ||\n        availableActions.includes(GameAction.ActionBuildRoad)\n          ? this.board.getAvailableRoads(currentPlayer)\n          : null,\n      buildableCities: null,\n    };\n    this.lobby.dispatchToCurrentPlayer(ServerEvents.AvailableActions, actions);\n  }\n\n  // dispatch updates to all clients\n  // questo va chiamato spesso all'interno di un singolo turnO\n  public dispatchDeltaUpdate(): void {\n    const updates: ServerPayloads[ServerEvents.DeltaUpdate] =\n      this.board.getDeltaUpdates();\n    this.lobby.dispatchToLobby(ServerEvents.DeltaUpdate, updates);\n  }\n\n  /**\n   *  receiving data from the clients\n   *\n   */\n  public triggerStartGame(): void {\n    // start the game\n    this.fsm.setupSteps = new Array(this.lobby.clients.size).fill(0);\n    this.turns = new TurnSystem(this.lobby);\n\n    this.board.initBoard();\n    this.hasStarted = true;\n\n    // send available actions to the current player\n    this.dispatchAvailableActions();\n  }\n\n  public getBoard(): {\n    spots: string;\n    tiles: string;\n    roads: string;\n  } {\n    console.log(JSON.stringify(Object.fromEntries(this.board.roads)));\n    const data = {\n      tiles: JSON.stringify(Object.fromEntries(this.board.tiles)),\n      spots: JSON.stringify(Object.fromEntries(this.board.spots)),\n      roads: JSON.stringify(Object.fromEntries(this.board.roads)),\n    };\n    return data;\n  }\n\n  public triggerFinish(): void {\n    if (!this.hasStarted) {\n      return;\n    }\n\n    this.lobby.dispatchToLobby<ServerPayloads[ServerEvents.GameMessage]>(\n      ServerEvents.GameMessage,\n      {\n        color: 'blue',\n        message: 'Game finished !',\n      }\n    );\n  }\n  public triggerPlayerDisconnect(client: AuthenticatedSocket): void {\n    this.lobby.dispatchToLobby<ServerPayloads[ServerEvents.GameMessage]>(\n      ServerEvents.GameMessage,\n      {\n        color: 'red',\n        message: `player ${client.data.username} disconnected`,\n      }\n    );\n  }\n\n  // gestire qui la logica del gioco\n  // e terminare con this.lobby.dispatchLobbyState per mandare aggionramenti a tutti i client\n  public onSetupSettlement(\n    client: AuthenticatedSocket,\n    data: ClientPayloads[GameAction.ActionSetupSettlement]\n  ): void {\n    const currentPlayerIndex = this.turns.getCurrentPlayerIndex();\n    const availableActions = this.fsm.getAvailableActions(currentPlayerIndex);\n\n    if (availableActions.includes(GameAction.ActionSetupSettlement)) {\n      this.board.buildSettlement(data.spotId, 'village', client.id);\n      this.fsm.setupSteps[currentPlayerIndex]++;\n      this.dispatchDeltaUpdate();\n      this.dispatchAvailableActions();\n    } else {\n      Logger.error('Not available action');\n    }\n  }\n\n  public onSetupRoad(\n    client: AuthenticatedSocket,\n    data: ClientPayloads[GameAction.ActionSetupRoad]\n  ): void {\n    // this can probably become some kind of decorator\n    const currentPlayerIndex = this.turns.getCurrentPlayerIndex();\n    const availableActions = this.fsm.getAvailableActions(currentPlayerIndex);\n\n    // check that the action is legit from this state\n    if (availableActions.includes(GameAction.ActionSetupRoad)) {\n      this.board.buildRoad(data.spot1, data.spot2, client.id);\n      this.fsm.setupSteps[currentPlayerIndex]++;\n      this.turns.nextTurn();\n      if (this.turns.getCurrentRound() === this.lobby.maxClients * 2) {\n        // end of setup stage\n        this.fsm.transitionTo('DICE_ROLL');\n      }\n      this.dispatchAvailableActions();\n      this.dispatchDeltaUpdate();\n    } else {\n      Logger.error('Not available action');\n    }\n  }\n  public onDiceRoll(client: AuthenticatedSocket, data: any): void {\n    Logger.log('diceRoll');\n    // this.fsm.transitionTo(state) // to turn?\n  }\n\n  public onEndTurn(client: AuthenticatedSocket): void {\n    const currentPlayerIndex = this.turns.getCurrentPlayerIndex();\n    const availableActions = this.fsm.getAvailableActions(currentPlayerIndex);\n\n    // check that the action is legit from this state\n    if (availableActions.includes(GameAction.ActionEndTurn)) {\n      // this.fsm.transitionTo(state) // to dice roll?\n      this.turns.nextTurn();\n    }\n  }\n\n  // public onBuildRoad() { }\n  // public onBuildSettlement() { }\n}\n\n```\nhere at line 88 I stringify the object to send it over sockets. however, the `yangle` is not contained.\nI can help identify why the `yangle` might be missing when you stringify the roads object. Looking at the code, there could be a few potential issues:\n\n1. **Initialization and Assignment**: In the `initRoad` method of `MapBoard`, the road is being set in multiple places. Let's make sure the `yangle` is properly assigned:\n\n```typescript\npublic initRoad(road_id: Road['id'], spot1: Spot['id'], spot2: Spot['id']): void {\n  const screenPosition: roadScreenPosition = this.roadScreenPositionGivenSpots(spot1, spot2);\n  \n  // Create a single road object to reuse\n  const roadObject = {\n    id: road_id,\n    owner: null,\n    position: {\n      board: {\n        from: spot1,\n        to: spot2,\n      },\n      screen: {\n        x: screenPosition.x,\n        y: screenPosition.y,\n        z: screenPosition.z,\n        yangle: screenPosition.yangle  // Make sure this is included\n      },\n    },\n  };\n\n  // Use the same object for both directions in the graph\n  this.roadsGraph[spot1][spot2] = {...roadObject};\n  this.roadsGraph[spot2][spot1] = {\n    ...roadObject,\n    position: {\n      ...roadObject.position,\n      board: { from: spot2, to: spot1 }\n    }\n  };\n  \n  // Set in the roads Map\n  this.roads.set(road_id, roadObject);\n}\n```\n\n2. **Debugging**: Add some console.logs to verify the `yangle` is being calculated and assigned correctly:\n\n```typescript\nprivate roadScreenPositionGivenSpots(spot1: Spot['id'], spot2: Spot['id']): roadScreenPosition {\n  // ... existing code ...\n\n  console.log('Road yangle:', yangle); // Add this debug line\n  \n  const position = {\n    x: midX,\n    y: this.Y_ROAD,\n    z: midZ,\n    yangle,\n  };\n  \n  console.log('Road position:', position); // Add this debug line\n  return position;\n}\n```\n\n3. **Verify Serialization**: In your Instance class, add a debug log before stringifying:\n\n```typescript\npublic getBoard(): {\n  spots: string;\n  tiles: string;\n  roads: string;\n} {\n  const roads = Object.fromEntries(this.board.roads);\n  console.log('Roads before stringify:', roads); // Add this debug line\n  \n  const data = {\n    tiles: JSON.stringify(Object.fromEntries(this.board.tiles)),\n    spots: JSON.stringify(Object.fromEntries(this.board.spots)),\n    roads: JSON.stringify(roads),\n  };\n  return data;\n}\n```\n\nThese changes should help ensure the `yangle` is properly included in the serialized data. The issue might be in how the road object is being constructed or how it's being assigned to the various data structures. The debug logs will help pinpoint where the `yangle` might be getting lost.\n\nAlso, make sure your Road type definition (in shared types) includes the `yangle` property in the screen position type:\n\n```typescript\ninterface RoadScreenPosition {\n  x: number;\n  y: number;\n  z: number;\n  yangle: number;\n}\n```\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":106}}},{"id":{"replica_id":0,"value":53},"start":16064,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":107}}},{"id":{"replica_id":0,"value":54},"start":18819,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":108}}}],"summary":"Road Angle Data Not Persisting","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}