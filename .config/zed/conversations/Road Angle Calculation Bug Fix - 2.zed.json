{"id":"0e805194-22a1-4547-bdd7-76103763575b","zed":"context","version":"0.4.0","text":"\n\n\n\n```ts settlers/packages/server/src/game/map/map.board.ts:1-355\n// Excerpt from: \nimport * as road_connections from './utils/road_connections.json';\nimport * as board_coordinates from './utils/board_coordinates.json';\nimport * as board_constants from './utils/board_constants.json';\nimport { Logger } from '@nestjs/common';\nimport {\n  Delta,\n  GameAction,\n  Resource,\n  Road,\n  ServerEvents,\n  ServerPayloads,\n  SettlementType,\n  Spot,\n  Tile,\n} from '@settlers/shared';\nimport { Socket } from 'socket.io';\nimport { randomInt } from 'crypto';\nimport { bfs_roads, bfs_spots } from './utils/bfs';\nimport {\n  roadScreenPosition,\n  screenPosition,\n  spotBoardPosition,\n  tileBoardPosition,\n} from 'packages/shared/src/lib/common/BoardTypes';\n\nexport class MapBoard {\n  private NUM_SPOTS = 54;\n  private Y_SPOT = 0.2;\n  private Y_ROAD = 0.18;\n  private Y_TILE = 0;\n  private HEX_SIZE = 0.6;\n  public spots: Map<Spot['id'], Spot> = new Map<Spot['id'], Spot>();\n  public tiles: Map<Tile['id'], Tile> = new Map<Tile['id'], Tile>();\n  public roads: Map<Road['id'], Road> = new Map<Road['id'], Road>();\n  deltas: Delta[] = [];\n\n  // potrebbe essere overkill, basta l'id e non l'intera road\n  public roadsGraph: {\n    [from: Spot['id']]: {\n      [to: Spot['id']]: Road['id'];\n    };\n  } = {};\n\n  constructor() {\n    for (let i = 1; i <= this.NUM_SPOTS; i++) {\n      this.roadsGraph[i] = {};\n    }\n  }\n\n  // initalise the graph\n  public initSpot(\n    spot_id: Spot['id'],\n    tilePositionBoard: tileBoardPosition,\n    spotPositionBoard: spotBoardPosition\n  ): void {\n    // get screen position of tile\n    const tileScreenPosition = this.tileBoardToScreen(tilePositionBoard);\n\n    // get spot position on screen\n    const spotTileCorner = spotPositionBoard.tileCorner;\n    const spotPositionScreen = this.spotBoardToScreen(\n      tileScreenPosition,\n      spotTileCorner\n    );\n\n    const spotData = {\n      id: spot_id,\n      owner: null,\n      settlementType: null,\n      position: {\n        screen: {\n          ...spotPositionScreen,\n        },\n        board: {\n          ...spotPositionBoard,\n        },\n      },\n    };\n    this.spots.set(spot_id, spotData);\n  }\n\n  public initRoad(\n    road_id: Road['id'],\n    spot1: Spot['id'],\n    spot2: Spot['id']\n  ): void {\n    const screenPosition: roadScreenPosition =\n      this.roadScreenPositionGivenSpots(spot1, spot2);\n    const roadObject = {\n      id: road_id,\n      owner: null,\n      position: {\n        board: {\n          from: spot1,\n          to: spot2,\n        },\n        screen: {\n          x: screenPosition.x,\n          y: screenPosition.y,\n          yangle: screenPosition.yangle,\n          z: screenPosition.z,\n        },\n      },\n    };\n\n    // i could directly import road_connections as roadsGraph\n    this.roadsGraph[spot1][spot2] = road_id;\n    this.roadsGraph[spot2][spot1] = road_id;\n    this.roads.set(road_id, roadObject);\n  }\n\n  public getDeltaUpdates(): ServerPayloads[ServerEvents.DeltaUpdate] {\n    const deltas = [...this.deltas];\n    this.deltas = [];\n    return deltas;\n  }\n\n  // helpers for coordinates\n  private spotBoardToScreen(\n    tileScreenPosition: screenPosition,\n    tileCorner: number\n  ): screenPosition {\n    const angle_deg = 60 * tileCorner + 30;\n    const angle_rad = (Math.PI / 180) * angle_deg;\n    const x = tileScreenPosition.x + this.HEX_SIZE * Math.cos(angle_rad);\n    const z = tileScreenPosition.z + this.HEX_SIZE * Math.sin(angle_rad);\n    return { x, y: this.Y_SPOT, z };\n  }\n\n  private tileBoardToScreen(boardPosition: tileBoardPosition): screenPosition {\n    const x =\n      this.HEX_SIZE *\n      (Math.sqrt(3) * boardPosition.q + (Math.sqrt(3) / 2) * boardPosition.r);\n    const z = this.HEX_SIZE * ((3 / 2) * boardPosition.r);\n    return { x, y: this.Y_TILE, z };\n  }\n\n  private roadScreenPositionGivenSpots(\n    spot1: Spot['id'],\n    spot2: Spot['id']\n  ): roadScreenPosition {\n    console.log('==');\n    // get spot positions on screen\n    const pos1: screenPosition = this.spots.get(spot1).position.screen;\n    const pos2: screenPosition = this.spots.get(spot2).position.screen;\n\n    // let yangle: number;\n    const x1: number = pos1.x;\n    const x2: number = pos2.x;\n    const z1: number = pos1.z;\n    const z2: number = pos2.z;\n\n    // calculate mid point\n    const midX: number = (x1 + x2) / 2;\n    const midZ: number = (z1 + z2) / 2;\n\n    console.log(`spot ${spot1} pos ${x1} ${z1}`);\n    console.log(`spot ${spot2} pos ${x2} ${z2}`);\n\n    const yangle = Math.atan2(z2, x1);\n    // calculate y rotation angle\n    // const epsilon = 0.0000001;\n    // if (x1 - x2 < epsilon && z2 < z1) {\n    //   yangle = Math.PI / 2;\n    //   console.log('|');\n    // } else if (x1 - x2 && z1 < z2) {\n    //   yangle = Math.PI / 6;\n    //   console.log('/');\n    // } else if (x1 < x2 && z1 < z2) {\n    //   yangle = (5 * Math.PI) / 6;\n    //   console.log('\\\\');\n    // }\n    console.log(`Yangle ${yangle}`);\n\n    return {\n      x: midX,\n      y: this.Y_ROAD,\n      z: midZ,\n      yangle,\n    };\n  }\n\n  // main initialisation function for the board\n  public initBoard(): void {\n    // initialise the 'graph' part of the board aka spots/roads\n    const tilesCoordinates = board_coordinates['tiles'];\n    const spotsCoordinates = board_coordinates['spots'];\n\n    // tiles\n    const tileValues = board_constants['tileValues'].sort(\n      () => Math.random() - 0.5\n    );\n    const tileResources: Resource[] = board_constants['resourceValues'].sort(\n      () => Math.random() - 0.5\n    ) as Resource[];\n    let valueIndex = 0;\n\n    for (let i = 0; i < tileResources.length; i++) {\n      const tileValue =\n        tileResources[i] === 'ROBBERS' ? 7 : tileValues[valueIndex++];\n      const tilePositionBoard: tileBoardPosition =\n        tilesCoordinates[(i + 1).toString()];\n      const tilePositionScreen: screenPosition =\n        this.tileBoardToScreen(tilePositionBoard);\n\n      this.tiles.set(i + 1, {\n        resource: tileResources[i],\n        value: tileValue,\n        id: i + 1,\n        position: {\n          board: tilePositionBoard,\n          screen: tilePositionScreen,\n        },\n      });\n    }\n\n    // spots and roads - currently doing 2 for loops because\n    // to calculate road screen position i need spots positions\n    for (\n      let spotId = 1;\n      spotId <= Object.keys(spotsCoordinates).length;\n      spotId++\n    ) {\n      const spotPositionBoard: spotBoardPosition =\n        spotsCoordinates[spotId.toString()];\n      const tilePositionBoard: tileBoardPosition = this.tiles.get(\n        spotPositionBoard.tile\n      ).position.board;\n      this.initSpot(spotId, tilePositionBoard, spotPositionBoard);\n    }\n\n    for (\n      let spotId = 1;\n      spotId <= Object.keys(spotsCoordinates).length;\n      spotId++\n    ) {\n      const from = spotId.toString();\n\n      for (const to of Object.keys(road_connections[from])) {\n        const roadId = road_connections[from][to];\n        const roadTobeSetup = this.roadsGraph[from][to] == undefined;\n\n        if (roadTobeSetup) {\n          this.initRoad(parseInt(roadId), parseInt(from), parseInt(to));\n        }\n      }\n    }\n    Logger.log('Board initialised');\n  }\n\n  public getAdjacentSpots(spot_id: Spot['id']): Array<Spot['id']> {\n    const r = Object.keys(this.roadsGraph[spot_id]);\n    return [];\n  }\n\n  // building roads and settlements\n  public getAvailableSpots = (player: Socket['id']): Array<Spot> => {\n    const settlementsBuiltByPlayer = this.getSettlementsBuiltBy(player);\n    if (settlementsBuiltByPlayer.length < 2) {\n      return this.getSettlementsBuiltBy(null);\n    }\n    return bfs_spots(settlementsBuiltByPlayer, this.spots, this.roads, player);\n  };\n\n  public getAvailableRoads = (player: Socket['id']): Array<Road> => {\n    const settlementsBuiltByPlayer = this.getSettlementsBuiltBy(player);\n    return bfs_roads(\n      settlementsBuiltByPlayer,\n      this.spots,\n      this.roadsGraph,\n      this.roads,\n      player\n    );\n  };\n\n  // there is for sure a better way\n  public getSettlementsBuiltBy = (player: Socket['id'] | null): Array<Spot> => {\n    const playerTowns = [];\n    for (const [, spot] of this.spots.entries()) {\n      if (spot.owner === player) playerTowns.push(spot);\n    }\n    return playerTowns;\n  };\n\n  public buildSettlement(\n    spot_id: Spot['id'],\n    settlement_type: SettlementType,\n    player: Socket['id']\n  ): void {\n    const spot = this.spots.get(spot_id);\n    this.spots.set(spot_id, {\n      ...spot,\n      owner: player,\n      settlementType: settlement_type,\n    });\n\n    // adjacent spots are not buildable anymore\n    const adjs = this.getAdjacentSpots(spot_id);\n    for (const adj of adjs) {\n      console.log(adj);\n    }\n\n    this.deltas.push({\n      action: GameAction.ActionBuildSettlement,\n      player,\n      details: {\n        newSettlement: spot_id,\n        adjacent: [...adjs],\n      },\n      timestamp: Date.now(),\n    });\n  }\n\n  public buildRoad(\n    spot1: Spot['id'],\n    spot2: Spot['id'],\n    player: Socket['id']\n  ): void {\n    // this.roadsGraph[spot1][spot2].owner = player;\n    // this.roadsGraph[spot2][spot1].owner = player;\n\n    const roadId = this.roadsGraph[spot1][spot2];\n    const road = this.roads.get(roadId);\n    this.roads.set(roadId, {\n      ...road,\n      owner: player,\n    });\n\n    console.log(`built: ${this.roadsGraph[spot1][spot2]}`);\n    this.deltas.push({\n      action: GameAction.ActionBuildRoad,\n      player,\n      details: {\n        newRoad: road,\n      },\n      timestamp: Date.now(),\n    });\n  }\n\n  public rollDice(player: Socket['id']): number[] {\n    const dice = [randomInt(1, 7), randomInt(1, 7)];\n\n    this.deltas.push({\n      action: GameAction.ActionDiceRoll,\n      player,\n      details: {\n        dice,\n      },\n      timestamp: Date.now(),\n    });\n\n    return dice;\n  }\n}\n\n```\nwhats wrong with my road angles? they are not correct.\nLooking at your `roadScreenPositionGivenSpots` function, the angle calculation appears to be incorrect. The current calculation `Math.atan2(z2, x1)` isn't giving you the correct angle between two points. Here's how you can fix it:\n\n```typescript\nprivate roadScreenPositionGivenSpots(\n  spot1: Spot['id'],\n  spot2: Spot['id']\n): roadScreenPosition {\n  // get spot positions on screen\n  const pos1: screenPosition = this.spots.get(spot1).position.screen;\n  const pos2: screenPosition = this.spots.get(spot2).position.screen;\n\n  const x1: number = pos1.x;\n  const x2: number = pos2.x;\n  const z1: number = pos1.z;\n  const z2: number = pos2.z;\n\n  // calculate mid point\n  const midX: number = (x1 + x2) / 2;\n  const midZ: number = (z1 + z2) / 2;\n\n  // Calculate angle using atan2 with differences between points\n  const yangle = Math.atan2(z2 - z1, x2 - x1);\n\n  return {\n    x: midX,\n    y: this.Y_ROAD,\n    z: midZ,\n    yangle,\n  };\n}\n```\n\nThe key changes are:\n\n1. Use `Math.atan2(z2 - z1, x2 - x1)` instead of `Math.atan2(z2, x1)`\n2. The angle should be calculated using the differences between the points to get the correct orientation\n\n`Math.atan2` takes two arguments:\n- y difference (z2 - z1 in this case since we're working in xz plane)\n- x difference (x2 - x1)\n\nThis will give you the correct angle in radians between the points, which you can use to rotate the road mesh properly. The angle will be:\n- 0 radians for horizontal roads going right\n- π/2 radians for vertical roads going up\n- -π/2 radians for vertical roads going down\n- π radians for horizontal roads going left\n\nThe roads should now align properly between the spots on your hexagonal board.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":46}}},{"id":{"replica_id":0,"value":19},"start":9804,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":47}}},{"id":{"replica_id":0,"value":20},"start":11468,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":48}}}],"summary":"Road Angle Calculation Bug Fix","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}